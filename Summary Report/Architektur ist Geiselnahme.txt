(4) Architectural Design

{intro}


(4.1) Overview



  +-----------------+       +-----------------+
  |                 |       |       web       |
  |    scheduler    |------*|   application   | <-----> USER
  |                 |       |                 |
  +-----------------+       +-----------------+
          ^ |                       ^ |
          | v                       | v
  +-------------------------------------------+
  |             Data Access Layer             |
  +-------------------------------------------+
                       ^ |
                       | v
                 +-------------+
                 |   Database  |
                 +-------------+


(4.2) scheduler

Solving the course scheduling problem is NP-hard. For providing a reasonably fast pre-scheduling, we wanted to use a genetic algorithm. Such algorithms roughly consist of three parts:

 * A fitness function
   which evaluates the quality of an intermediate solution,
 * A cross over function
   which intermixes two intermediate solutions in a specific manner in order to create a better solution,
 * A mutation function
   which randomly or intelligently refactors an intermediate solution,
 * The algorithm itself
   which controls the execution of the other parts, i.e. in what order the components are applied and how many intermediate solutions are created.
   
We decided to model these parts as exchangable components, i.e. individual objects, which could be combined in any way. Since we did not have any experience with these kind of algorithms this design should help us to better understand and scale the different parts of the algorithm.


(4.3) web application

Furthermore, we wanted to separate presentational logic from business logic within our web application. Thus we decided to go for a multi tier architecture and to split the web-application into three parts:

* Modules, which contain business logic
* Templates, which contain presentational logic
* A Servlet which provides data and control flow between Modules and Templates

+------------------------+
|    Modules (Model)     |
+------------------------+
           | ^
           v |
+------------------------+
|  Servlet (Controller)  |
+------------------------+
           | ^
           v |
+------------------------+
|    Templates (View)    |
+------------------------+


(4.4) data access layer

In order to create a proper model of the entities we were to work with, we decided to develop an object-relational model, from which the object-oriented classes as well as an entity-relationship-oriented model should be derived.

                +---------------------+
                |  object-relational  |
                |        model        |
                +---------------------+
                     /           \
                    /             \
                   v               v
            +------------+   +------------+
            |  OO model  |   |  ER model  |
            +------------+   +------------+

We did this in order to keep both the OO as well as the ER model consistent, since we needed both of them in order to setup an object-oriented application as well as a relational database.


(4.5) work flow

The intended work flow of our application (that is, the way the users interact with our software) should be the following:

1. Users enter data (which courses exist, preferences, requirements)
2. An authorized user freezes the database and lets the scheduler create an intermediate timetable
3. Users refine their preferences and requirements in order to solve conclicts deteced by the scheduler

The second and third steps should be executed as often as needed or wanted by the users of the system as to create a timetable as fast and as optimal as possible.


(5) Implementation

{Intro} (?)


(5.1) Technologies

We considered many technologies and looked at some of them intensively. Since we were building a web application we considered PHP, Ruby, Scala, pure Java and AspectJ as our main programming language. As the scheduler is a performance critical part of our application we soonly dropped interpreted languages. As we were all most familiar with Java and development tools for Java are widely available, we favored Java. We finally went with AspectJ, which is built on top of Java, since it offers great flexibility through so called Aspects. We will discuss the use of Aspects within our application more in-depth later on.

As database backend we chose PostgreSQL since it features strong adherence to the SQL standard and the best implementation of referential integrity in relational databases we knew of. Another strong argument for PostgreSQL was, that it allows for rich use of stored procedures, i.e. business logic within the database. As a matter of fact our application thus runs with PostgreSQL only, but could be ported to another database-engine easily, since only certain parts would have to be rewritten (PostgreSQL-specific parts within the data access layer and certain Aspects).

There is no choice about the lingua franca in the internet, thus we used web technologies like HTML and CSS in the front end. To keep things simple we stuck to related technologies which are all part of the XML family, like XSL-T. We will disucss the use of XML within our web application in the appropriate sections of this report.


(5.2) Code Generation using XML and XSL-T, and the data access layer

As mentioned in 4.4 we wanted to create a single domain model from which an OO model as well as an ER model should be derived. To achieve this, we developed a custom XML format to describe the entities and relationships in our application as well as some constraints defined on them. Using XSL-T we generated documentation in human-readable form (XHTML), Java code, and a PostgreSQL Schema in SQL/DDL.

(5.2.1) data access layer

The data access layer is thus completely auto generated from XSL-T templates. De facto the resulting Java classes implement the active record pattern, that is they are used to access data as well as to transfer data. They provide means for creating, updating, and deleting data. The API for the data access layer was designed with fluent interfaces in mind, such that methods which normally return void return the object itself as to increase the readability of code that uses our API.

  +-----------------------------------------------------------------+
  | Methods for accessing data:                                     |
  | + <Attribute-Type> get<Attribute>()                             |
  | + <This> set<Attribute>(<Attribute-Type> Value)                 |
  | + clear<Attribute>() (only available, if the value is nullable) |
  |                                                                 |
  | Methods for transfering data:                                   |
  | + pushChanges() -- update data to database                      |
  | + pullChanges() -- update data from database                    |
  | + create()      -- insert a dataset into the database           |
  | + delete()      -- delete a dataset from the database           |
  +-----------------------------------------------------------------+
  



(5.2.2) Special functions using AspectJ and PL/pgSQL


(5.4) MVC using Java Annotation and Reflections





